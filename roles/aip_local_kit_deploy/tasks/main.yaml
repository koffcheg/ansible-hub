---
# 0) Validate required params
- name: Fail if kit archive not provided
  ansible.builtin.fail:
    msg: |
      You must pass:
        -e "aip_kit_archive=<file>.tar.zst"
  when: aip_kit_archive is not defined or (aip_kit_archive | string | length) == 0

- name: Fail if store_id not provided
  ansible.builtin.fail:
    msg: |
      You must pass:
        -e "aip_store_id=<STORE_ID>"
  when: aip_store_id is not defined or (aip_store_id | string | length) == 0

# 1) Compute archive path
- name: Compute full archive path
  ansible.builtin.set_fact:
    kit_archive_path: "{{ aip_eject_kits_root }}/{{ aip_kit_archive }}"

- name: Check archive exists
  ansible.builtin.stat:
    path: "{{ kit_archive_path }}"
  register: kit_stat

- name: Fail if archive missing
  ansible.builtin.fail:
    msg: "Archive '{{ kit_archive_path }}' not found on Jetson."
  when: not kit_stat.stat.exists

# 2) Derive deployment directory name
- name: Derive kit basename
  ansible.builtin.set_fact:
    kit_basename: "{{ aip_kit_archive | regex_replace('\\.tar\\.[^.]+$', '') }}"

- name: Derive deployment directory
  ansible.builtin.set_fact:
    deploy_dir: "{{ aip_deploy_root }}/{{ kit_basename }}"

- name: Debug derived paths
  ansible.builtin.debug:
    msg:
      - "kit_archive_path = {{ kit_archive_path }}"
      - "kit_basename    = {{ kit_basename }}"
      - "deploy_dir      = {{ deploy_dir }}"

# 3) Ensure deploy root exists
- name: Ensure deployments root exists
  ansible.builtin.file:
    path: "{{ aip_deploy_root }}"
    state: directory
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0755"

# 4) Create version dir
- name: Create deploy_dir
  ansible.builtin.file:
    path: "{{ deploy_dir }}"
    state: directory
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0755"

# 5) Extract archive as checkout
- name: Extract kit archive
  become: true
  become_user: "{{ aip_deploy_user }}"
  ansible.builtin.shell: >
    tar -I zstd -xf "{{ kit_archive_path }}"
    -C "{{ deploy_dir }}"
    --strip-components=1
  args:
    executable: /bin/bash

# 6) Run installer AS ROOT with JSON output
- name: Run jetson installer (JSON mode)
  become: true              # main.sh must run as root
  ansible.builtin.shell: >
    ./main.sh
    --auto
    --store-id {{ aip_store_id }}
    --json
    "{{ deploy_dir }}"
  args:
    chdir: "{{ deploy_dir }}/jetson_installer"
    executable: /bin/bash
  register: installer_run
  changed_when: true
  failed_when: false        # interpret rc + JSON ourselves

# 7) Parse JSON result from installer output (if present)

# Grab the first {...} block from stdout as a whole, not line-by-line.
- name: Extract JSON block from installer stdout
  ansible.builtin.set_fact:
    installer_json_block: >-
      {{ installer_run.stdout | regex_search('(?s){.*}') | default('') }}

- name: Parse installer JSON (via from_yaml, JSON is a subset of YAML)
  when: installer_json_block != ''
  ansible.builtin.set_fact:
    installer_result: "{{ installer_json_block | from_yaml }}"

- name: Debug parsed installer_result
  ansible.builtin.debug:
    var: installer_result
  when: installer_result is defined

# 8) Guardrail: non-zero rc with no JSON is a hard failure
- name: Fail if installer exited non-zero and no JSON status could be parsed
  ansible.builtin.fail:
    msg: >
      EcoBoutique installer exited with code {{ installer_run.rc }} and no JSON
      status could be parsed.
      stdout: {{ installer_run.stdout }}
      stderr: {{ installer_run.stderr }}
  when:
    - installer_run.rc != 0
    - installer_result is not defined

# 9) Hard-fail only for core steps; treat pure postinstall failures as soft
#    We consider failed_step < 11 as "hard" (preflight / core install).
- name: Fail play if installer encountered a hard error
  ansible.builtin.fail:
    msg: >
      EcoBoutique installer reported failure at step {{ installer_result.failed_step | default('unknown') }}:
      {{ installer_result.message | default('no message') }}
  when: >
    installer_result is defined and
    (installer_result.status | default('')) == 'failed' and
    (
      installer_result.failed_step is not defined or
      (installer_result.failed_step | int) < 11
    )

# 10) Update symlink to this version (installer also does this, but idempotent here)
- name: Update 'current' symlink
  become: true
  ansible.builtin.file:
    src: "{{ deploy_dir }}"
    dest: "{{ aip_deploy_root }}/current"
    state: link
    force: true

# 11) Write receipt
- name: Write deploy receipt
  become: true
  ansible.builtin.copy:
    dest: "{{ deploy_dir }}/deploy.receipt"
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0644"
    content: |
      deployed_at={{ ansible_date_time.iso8601 }}
      archive={{ kit_archive_path }}
      deploy_dir={{ deploy_dir }}
      host={{ inventory_hostname }}
      installer_rc={{ installer_run.rc }}
      installer_status={{ installer_result.status | default('unknown') if installer_result is defined else 'no-json' }}
      installer_failed_step={{ installer_result.failed_step | default('n/a') if installer_result is defined else 'n/a' }}
