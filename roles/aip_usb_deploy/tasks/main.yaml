---
# 0) Discover archive name (blob_name) from extra-var or /etc/aip/deploy.env

- name: Read /etc/aip/deploy.env when aip_blob_name is not provided
  become: true
  stat:
    path: /etc/aip/deploy.env
  register: aip_deploy_env
  when: aip_blob_name is not defined or aip_blob_name | trim | length == 0

- name: Read BLOB_NAME from /etc/aip/deploy.env
  become: true
  command: "awk -F= '/^BLOB_NAME=/{print $2}' /etc/aip/deploy.env"
  register: aip_blob_from_env
  changed_when: false
  when:
    - aip_deploy_env is defined
    - aip_deploy_env.stat.exists
    - aip_blob_name is not defined or aip_blob_name | trim | length == 0

- name: Set blob_name from extra var
  set_fact:
    blob_name: "{{ aip_blob_name | trim }}"
  when: aip_blob_name is defined and aip_blob_name | trim | length > 0

- name: Set blob_name from /etc/aip/deploy.env
  set_fact:
    blob_name: "{{ aip_blob_from_env.stdout | trim }}"
  when:
    - blob_name is not defined
    - aip_blob_from_env is defined
    - aip_blob_from_env.stdout is defined
    - aip_blob_from_env.stdout | trim | length > 0

- name: Fail if blob_name could not be determined
  fail:
    msg: >
      Unable to determine AIP archive name (blob_name).
      Provide -e "aip_blob_name=..." OR set BLOB_NAME=... in /etc/aip/deploy.env.
  when: blob_name is not defined or blob_name | trim | length == 0

# 0.1) Derive kit version and deploy_dir

- name: Derive kit version and deployment directory
  set_fact:
    archive_name: "{{ blob_name | trim }}"
    archive_basename: "{{ (blob_name | trim) | regex_replace('\\.tar\\.zst$', '') }}"
    aip_effective_kit_version: >-
      {% if aip_kit_version is defined and aip_kit_version | trim | length > 0 -%}
      {{ aip_kit_version | trim }}
      {%- else -%}
      {{ ((blob_name | trim) | regex_replace('\\.tar\\.zst$', '')) | split('-') | last }}
      {%- endif %}
    deploy_dir: "{{ aip_deploy_root }}/{{ ((blob_name | trim) | regex_replace('\\.tar\\.zst$', '')) | split('-') | last }}"

- name: Show derived kit version and deploy_dir
  debug:
    msg:
      - "Archive name: {{ archive_name }}"
      - "Kit version: {{ aip_effective_kit_version }}"
      - "Deploy dir:  {{ deploy_dir }}"

# 0.2) Validate required inputs

- name: Fail if aip_store_id is not provided
  fail:
    msg: "aip_store_id must be provided (e.g. via -e 'aip_store_id=115')."
  when: aip_store_id is not defined or aip_store_id | trim | length == 0

# 1) Locate archive on USB (AIP_DEPLOY) or in eject_kits

- name: Detect AIP_DEPLOY USB mount point
  become: true
  shell: "find /media -maxdepth 2 -type d -name 'AIP_DEPLOY' | head -n1"
  register: usb_mp
  changed_when: false

- name: Check for archive on USB
  become: true
  stat:
    path: "{{ usb_mp.stdout | trim }}/{{ archive_name }}"
  register: usb_archive
  when: usb_mp.stdout is defined and usb_mp.stdout | trim != ""

- name: Set archive_src_path from USB when present
  set_fact:
    archive_src_path: "{{ usb_mp.stdout | trim }}/{{ archive_name }}"
    archive_src_dir: "{{ usb_mp.stdout | trim }}"
  when:
    - usb_archive is defined
    - usb_archive.stat.exists

- name: Fallback – check for archive in eject_kits dir
  become: true
  stat:
    path: "{{ aip_eject_kits_dir }}/{{ archive_name }}"
  register: home_archive
  when: archive_src_path is not defined

- name: Set archive_src_path from eject_kits dir
  set_fact:
    archive_src_path: "{{ aip_eject_kits_dir }}/{{ archive_name }}"
    archive_src_dir: "{{ aip_eject_kits_dir }}"
  when:
    - archive_src_path is not defined
    - home_archive.stat.exists

- name: Fail if archive not found
  fail:
    msg: >-
      AIP USB deploy: archive '{{ archive_name }}' not found.
      Checked:
        - {{ usb_mp.stdout | default('/media/.../AIP_DEPLOY') }}/{{ archive_name }}
        - {{ aip_eject_kits_dir }}/{{ archive_name }}
  when: archive_src_path is not defined

# 2) Verify checksum using local .sha256

- name: Ensure AIP state/stage directory exists
  become: true
  file:
    path: "{{ aip_state_stage_dir }}"
    state: directory
    owner: root
    group: root
    mode: "0700"

- name: Copy checksum file to stage dir
  become: true
  copy:
    src: "{{ archive_src_path }}.sha256"
    dest: "{{ aip_state_stage_dir }}/{{ archive_name }}.sha256"
    mode: "0600"
    remote_src: true

- name: Verify SHA256 checksum of the archive
  become: true
  command: "sha256sum --check {{ aip_state_stage_dir }}/{{ archive_name }}.sha256"
  args:
    chdir: "{{ archive_src_dir }}"

# 3) Extract archive into {{ aip_deploy_root }}

- name: Ensure deployment root exists
  become: true
  file:
    path: "{{ aip_deploy_root }}"
    state: directory
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0755"

- name: Extract AIP kit archive into deployment root
  become: true
  become_user: "{{ aip_deploy_user }}"
  command: >
    tar -I zstd -xf "{{ archive_src_path }}"
    -C "{{ aip_deploy_root }}"
  args:
    creates: "{{ deploy_dir }}"
  register: extract_result

- name: Ensure deploy_dir exists after extraction
  become: true
  stat:
    path: "{{ deploy_dir }}"
  register: deploy_dir_stat

- name: Fail if deploy_dir was not created
  fail:
    msg: "Expected deploy_dir '{{ deploy_dir }}' to exist after extraction, but it does not."
  when: not deploy_dir_stat.stat.exists

# 4) Optionally stop before running jetson_installer (dry-run mode)

- name: Dry-run mode – skip jetson_installer execution
  debug:
    msg:
      - "Dry run is enabled (aip_installer_dry_run=true)."
      - "Archive was verified and extracted to {{ deploy_dir }}."
      - "You can now inspect {{ deploy_dir }}/jetson_installer/main.sh manually."
  when: aip_installer_dry_run | bool

# 5) Run jetson_installer/main.sh in --auto mode (if not dry run)

- name: Ensure jetson_installer/main.sh is executable
  become: true
  file:
    path: "{{ deploy_dir }}/jetson_installer/main.sh"
    mode: "0755"
  when: not (aip_installer_dry_run | bool)

- name: Run EcoBoutique jetson installer in auto mode
  become: true
  args:
    chdir: "{{ deploy_dir }}/jetson_installer"
  command: >
    ./main.sh
    --auto
    --store-id {{ aip_store_id }}
    {% if aip_nats_url is defined and aip_nats_url | trim | length > 0 %}--nats-url {{ aip_nats_url }}{% endif %}
    --json
    {{ deploy_dir }}
  register: install_result
  retries: "{{ aip_installer_retries }}"
  delay: "{{ aip_installer_delay_seconds }}"
  until: install_result.rc == 0
  when: not (aip_installer_dry_run | bool)

- name: Parse installer JSON result
  set_fact:
    aip_install_status: "{{ (install_result.stdout_lines | last) | from_json }}"
  when:
    - not (aip_installer_dry_run | bool)
    - install_result.stdout_lines is defined
    - install_result.stdout_lines | length > 0

- name: Show installer JSON status
  debug:
    var: aip_install_status
  when: aip_install_status is defined

- name: Fail if installer reported non-success status
  fail:
    msg: "Jetson installer reported failure: {{ aip_install_status }}"
  when:
    - not (aip_installer_dry_run | bool)
    - aip_install_status is defined
    - aip_install_status.status is defined
    - aip_install_status.status != "success"

# 6) Write deployment receipt

- name: Ensure receipts directory exists
  become: true
  file:
    path: "{{ aip_state_receipts_dir }}"
    state: directory
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0755"

- name: Write deploy receipt on Jetson
  become: true
  copy:
    dest: "{{ aip_state_receipts_dir }}/{{ archive_name }}.receipt"
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0644"
    content: |
      archive_name={{ archive_name }}
      kit_version={{ aip_effective_kit_version }}
      deploy_dir={{ deploy_dir }}
      store_id={{ aip_store_id }}
      nats_url={{ aip_nats_url }}
      archive_src_path={{ archive_src_path }}
      deployed_at={{ ansible_date_time.iso8601 }}
      host={{ inventory_hostname }}

# 7) Cleanup checksum from stage dir
