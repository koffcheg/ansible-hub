---
# roles/aip_usb_deploy/tasks/main.yml

# 0) Discover blob_name (from extra-var or /etc/aip/deploy.env)
- name: Ensure /etc/aip/deploy.env exists
  become: true
  stat:
    path: /etc/aip/deploy.env
  register: aip_deploy_env

- name: Fail if /etc/aip/deploy.env is missing and no aip_blob_name was provided
  fail:
    msg: >
      /etc/aip/deploy.env does not exist and no aip_blob_name extra var was provided.
      Either:
        1) pass -e "aip_blob_name=..." to ansible-playbook, or
        2) create /etc/aip/deploy.env with a BLOB_NAME=... line.
  when:
    - not aip_deploy_env.stat.exists
    - (aip_blob_name is not defined or aip_blob_name | trim | length == 0)

- name: Read BLOB_NAME from /etc/aip/deploy.env if aip_blob_name not provided
  become: true
  command: "awk -F= '/^BLOB_NAME=/{print $2}' /etc/aip/deploy.env"
  register: aip_blob_from_env
  changed_when: false
  when:
    - aip_deploy_env.stat.exists
    - aip_blob_name is not defined or aip_blob_name | trim | length == 0

- name: Set effective blob_name from extra var
  set_fact:
    blob_name: "{{ aip_blob_name | trim }}"
  when: aip_blob_name is defined and aip_blob_name | trim | length > 0

- name: Set effective blob_name from /etc/aip/deploy.env
  set_fact:
    blob_name: "{{ aip_blob_from_env.stdout | trim }}"
  when:
    - blob_name is not defined
    - aip_blob_from_env is defined
    - aip_blob_from_env.stdout is defined
    - aip_blob_from_env.stdout | trim | length > 0

- name: Fail if blob_name could not be determined
  fail:
    msg: >
      Unable to determine blob_name.
      Provide -e "aip_blob_name=..." OR set BLOB_NAME=... in /etc/aip/deploy.env.
  when: blob_name is not defined or blob_name | trim | length == 0

# 0.1) Derive plaintext tar name and deploy_dir
- name: Derive plaintext archive name and deploy_dir
  set_fact:
    plaintext_tar_name: "{{ blob_name | regex_replace('\\.gpg$', '') }}"
    deploy_dir: "{{ aip_deploy_root }}/{{ blob_name | regex_replace('\\.gpg$', '') }}"

# 0.2) Mock mode – create dummy cipher blob and mark as staged
- name: Mock mode - create dummy staged blob and set cipher_src_path
  when: aip_usb_mock_mode | default(false) | bool
  become: true
  block:
    - name: Ensure deploy_root and .staged directories exist
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ aip_deploy_user }}"
        group: "{{ aip_deploy_user }}"
        mode: "0755"
      loop:
        - "{{ aip_deploy_root }}"
        - "{{ aip_deploy_root }}/.staged"

    - name: Write dummy cipher blob in deploy_root
      copy:
        dest: "{{ aip_deploy_root }}/{{ blob_name }}"
        content: "MOCK AIP BLOB {{ blob_name }} - not a real archive\n"
        owner: "{{ aip_deploy_user }}"
        group: "{{ aip_deploy_user }}"
        mode: "0644"

    - name: Write staged status file for dummy blob
      copy:
        dest: "{{ aip_deploy_root }}/.staged/{{ blob_name }}.status"
        content: "staged\n"
        owner: "{{ aip_deploy_user }}"
        group: "{{ aip_deploy_user }}"
        mode: "0644"

    - name: Set cipher_src_path fact for mock mode
      set_fact:
        cipher_src_path: "{{ aip_deploy_root }}/{{ blob_name }}"

# 1) Determine cipher_src_path in real mode (USB first, then home fallback)

- name: Detect AIP_DEPLOY USB mount point
  when: not (aip_usb_mock_mode | default(false) | bool)
  become: true
  shell: "find /media -maxdepth 2 -type d -name 'AIP_DEPLOY' | head -n1"
  register: usb_mp
  changed_when: false

- name: Check if USB stager reported success (if USB is present)
  when:
    - not (aip_usb_mock_mode | default(false) | bool)
    - usb_mp.stdout is defined
    - usb_mp.stdout | trim != ""
  become: true
  command: "cat {{ aip_deploy_root }}/.staged/{{ blob_name }}.status"
  register: staged_status
  changed_when: false
  failed_when: "'staged' not in staged_status.stdout"

- name: Set cipher_src_path from staged USB blob
  when:
    - not (aip_usb_mock_mode | default(false) | bool)
    - usb_mp.stdout is defined
    - usb_mp.stdout | trim != ""
  set_fact:
    cipher_src_path: "{{ aip_deploy_root }}/{{ blob_name }}"

- name: Fallback - check for blob in checkout home
  when:
    - not (aip_usb_mock_mode | default(false) | bool)
    - cipher_src_path is not defined
  become: true
  stat:
    path: "/home/{{ aip_deploy_user }}/{{ blob_name }}"
  register: fallback_blob

- name: Set cipher_src_path from fallback
  when:
    - not (aip_usb_mock_mode | default(false) | bool)
    - cipher_src_path is not defined
    - fallback_blob.stat.exists
  set_fact:
    cipher_src_path: "/home/{{ aip_deploy_user }}/{{ blob_name }}"

- name: Fail if blob not found in staged deployments or home
  when: cipher_src_path is not defined
  fail:
    msg: >-
      AIP USB deploy: blob '{{ blob_name }}' not found. Expected either
      '{{ aip_deploy_root }}/{{ blob_name }}' (staged from USB) or
      '/home/{{ aip_deploy_user }}/{{ blob_name }}'.

# 2) Controller-side: temp dir & checksum artifacts (real mode only)

- name: Ensure controller-side temp dir exists
  delegate_to: localhost
  run_once: true
  file:
    path: "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}"
    state: directory
    mode: "0700"

- name: Download checksum file from GCS
  delegate_to: localhost
  run_once: true
  when: not (aip_usb_mock_mode | default(false) | bool)
  environment:
    CLOUDSDK_CORE_PROJECT: "{{ aip_gcp_project }}"
  command: >
    gsutil cp
    "gs://{{ aip_usb_bucket }}/deployments/{{ blob_name }}/{{ blob_name }}.sha256"
    "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/"
  changed_when: true

- name: Download checksum signature (.minisig) from GCS
  delegate_to: localhost
  run_once: true
  when: not (aip_usb_mock_mode | default(false) | bool)
  environment:
    CLOUDSDK_CORE_PROJECT: "{{ aip_gcp_project }}"
  command: >
    gsutil cp
    "gs://{{ aip_usb_bucket }}/deployments/{{ blob_name }}/{{ blob_name }}.sha256.minisig"
    "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/"
  changed_when: true

- name: Verify checksum signature with minisign
  delegate_to: localhost
  run_once: true
  when: not (aip_usb_mock_mode | default(false) | bool)
  command: >
    minisign -Vm "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/{{ blob_name }}.sha256"
    -P "{{ aip_minisign_pubkey_path_controller }}"
  changed_when: false

# 3) Controller-side: fetch GPG secrets (real mode only)

- name: Ensure controller-side secrets dir exists
  delegate_to: localhost
  run_once: true
  file:
    path: "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets"
    state: directory
    mode: "0700"

- name: Fetch GPG private key from GSM
  delegate_to: localhost
  run_once: true
  when:
    - aip_decrypt_mode == 'asymmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  environment:
    CLOUDSDK_CORE_PROJECT: "{{ aip_gcp_project }}"
  command: >
    gcloud secrets versions access latest
    --secret="{{ aip_gpg_private_key_secret }}"
    --out-file="{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets/gpg-private.key"

- name: Fetch GPG private key passphrase from GSM
  delegate_to: localhost
  run_once: true
  when:
    - aip_decrypt_mode == 'asymmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  environment:
    CLOUDSDK_CORE_PROJECT: "{{ aip_gcp_project }}"
  command: >
    gcloud secrets versions access latest
    --secret="{{ aip_gpg_private_key_pass_secret }}"
    --out-file="{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets/gpg-private.pass"

- name: Fetch GPG symmetric passphrase from GSM
  delegate_to: localhost
  run_once: true
  when:
    - aip_decrypt_mode == 'symmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  environment:
    CLOUDSDK_CORE_PROJECT: "{{ aip_gcp_project }}"
  command: >
    gcloud secrets versions access latest
    --secret="{{ aip_gpg_symmetric_pass_secret }}"
    --out-file="{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets/gpg-symmetric.pass"

# 4) Push checksum & secrets to Jetson (real mode only)

- name: Copy checksum file to Jetson
  become: true
  when: not (aip_usb_mock_mode | default(false) | bool)
  copy:
    src: "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/{{ blob_name }}.sha256"
    dest: "{{ aip_state_stage_dir }}/{{ blob_name }}.sha256"
    mode: "0600"

- name: Copy GPG symmetric passphrase to Jetson
  become: true
  when:
    - aip_decrypt_mode == 'symmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  copy:
    src: "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets/gpg-symmetric.pass"
    dest: "{{ aip_state_stage_dir }}/gpg-symmetric.pass"
    mode: "0600"

- name: Copy GPG private key and passphrase to Jetson
  become: true
  when:
    - aip_decrypt_mode == 'asymmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
    mode: "0600"
  loop:
    - src: "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets/gpg-private.key"
      dest: "{{ aip_state_stage_dir }}/gpg-private.key"
    - src: "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets/gpg-private.pass"
      dest: "{{ aip_state_stage_dir }}/gpg-private.pass"

# 5) Verify checksums and decrypt on Jetson (real mode only)

- name: Verify SHA256 of the local ciphertext blob
  become: true
  when: not (aip_usb_mock_mode | default(false) | bool)
  command: "sha256sum --check {{ aip_state_stage_dir }}/{{ blob_name }}.sha256"
  args:
    chdir: "{{ cipher_src_path | dirname }}"

- name: Ensure deploy root exists
  become: true
  file:
    path: "{{ aip_deploy_root }}"
    state: directory
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0755"

- name: Ensure version-specific deploy dir exists
  become: true
  file:
    path: "{{ deploy_dir }}"
    state: directory
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0755"

- name: Decrypt blob to plaintext tarball (symmetric mode)
  become: true
  when:
    - aip_decrypt_mode == 'symmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  command: >
    gpg --batch --yes
    --passphrase-file "{{ aip_state_stage_dir }}/gpg-symmetric.pass"
    --output "{{ aip_state_stage_dir }}/{{ plaintext_tar_name }}"
    --decrypt "{{ cipher_src_path }}"

- name: Import GPG private key (asymmetric mode)
  become: true
  when:
    - aip_decrypt_mode == 'asymmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  command: >
    gpg --batch --yes
    --passphrase-file "{{ aip_state_stage_dir }}/gpg-private.pass"
    --import "{{ aip_state_stage_dir }}/gpg-private.key"

- name: Decrypt blob to plaintext tarball (asymmetric mode)
  become: true
  when:
    - aip_decrypt_mode == 'asymmetric'
    - not (aip_usb_mock_mode | default(false) | bool)
  no_log: true
  command: >
    gpg --batch --yes
    --output "{{ aip_state_stage_dir }}/{{ plaintext_tar_name }}"
    --decrypt "{{ cipher_src_path }}"

- name: Extract decrypted tar.zst into version dir (real mode)
  become: true
  when: not (aip_usb_mock_mode | default(false) | bool)
  args:
    chdir: "{{ deploy_dir }}"
  shell: |
    set -euo pipefail
    tar -I zstd -xf "{{ aip_state_stage_dir }}/{{ plaintext_tar_name }}"

# 6) Mock mode – create dummy deployment tree

- name: Mock mode – create dummy deployment tree
  become: true
  when: aip_usb_mock_mode | default(false) | bool
  block:
    - name: Ensure mock deploy dir exists
      file:
        path: "{{ deploy_dir }}"
        state: directory
        owner: "{{ aip_deploy_user }}"
        group: "{{ aip_deploy_user }}"
        mode: "0755"

    - name: Install a dummy docker-compose.yml for mock
      copy:
        dest: "{{ deploy_dir }}/{{ aip_compose_file_relpath }}"
        owner: "{{ aip_deploy_user }}"
        group: "{{ aip_deploy_user }}"
        mode: "0644"
        content: |
          version: "3.9"
          services:
            hello-aip:
              image: alpine:3
              command: ["sh", "-c", "echo 'Hello from AIP mock deployment'; sleep 3600"]

# 7) Docker images + compose

- name: Load Docker images from archive (if any *.tar)
  become: true
  become_user: "{{ aip_deploy_user }}"
  shell: |
    set -euo pipefail
    shopt -s nullglob
    for img in {{ deploy_dir }}/*.tar; do
      echo "[AIP] Loading Docker image $img"
      docker load -i "$img"
    done
  args:
    executable: /bin/bash
  changed_when: false

- name: Bring up docker compose stack from new version
  become: true
  become_user: "{{ aip_deploy_user }}"
  when: aip_compose_enabled
  args:
    chdir: "{{ deploy_dir }}/{{ aip_compose_workdir_relpath }}"
    executable: /bin/bash
  shell: |
    set -euo pipefail
    docker compose -f "{{ deploy_dir }}/{{ aip_compose_file_relpath }}" up -d --remove-orphans

# 8) Update symlink & receipt

- name: Update 'current' symlink to point to the new version
  become: true
  file:
    src: "{{ deploy_dir }}"
    dest: "{{ aip_deploy_root }}/current"
    state: link
    force: true

- name: Write deploy receipt on Jetson
  become: true
  copy:
    dest: "{{ aip_state_receipts_dir }}/{{ blob_name }}.receipt"
    owner: "{{ aip_deploy_user }}"
    group: "{{ aip_deploy_user }}"
    mode: "0644"
    content: |
      blob_name={{ blob_name }}
      plaintext_tar={{ plaintext_tar_name }}
      deploy_dir={{ deploy_dir }}
      deployed_at={{ ansible_date_time.iso8601 }}
      host={{ inventory_hostname }}

# 9) Cleanup secrets and temp files

- name: Remove secrets and temp files from Jetson
  become: true
  no_log: true
  file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ aip_state_stage_dir }}/gpg-symmetric.pass"
    - "{{ aip_state_stage_dir }}/gpg-private.key"
    - "{{ aip_state_stage_dir }}/gpg-private.pass"
    - "{{ aip_state_stage_dir }}/{{ plaintext_tar_name }}"
    - "{{ aip_state_stage_dir }}/{{ blob_name }}.sha256"

- name: Remove secrets from controller
  delegate_to: localhost
  run_once: true
  no_log: true
  file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/secrets"
    - "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/{{ blob_name }}.sha256"
    - "{{ aip_controller_tmp_root }}/{{ inventory_hostname }}/{{ blob_name }}/{{ blob_name }}.sha256.minisig"
